"""In-memory device registry and join code store for watch pairing."""

from __future__ import annotations

import base64
import hashlib
import hmac
import secrets
import time
from dataclasses import dataclass, replace
from threading import Lock
from typing import Dict, Optional


@dataclass(slots=True)
class Device:
    """Registered watch device bound to an optional member."""

    device_id: str
    device_secret: str
    bound_member_id: str | None = None
    last_seen_ts: int = 0
    last_ack_tip_id: str | None = None


@dataclass(slots=True)
class JoinCode:
    """Short-lived code generated by a member to pair a device."""

    code: str
    member_id: str
    exp_ts: int


_DEVICES: Dict[str, Device] = {}
_CODES: Dict[str, JoinCode] = {}
_LOCK = Lock()


def _now_s() -> int:
    return int(time.time())


def _new_id(n: int = 12) -> str:
    raw = secrets.token_bytes(n)
    return base64.urlsafe_b64encode(raw).decode().rstrip("=")


def _purge_expired_codes(now: int | None = None) -> None:
    current = _now_s() if now is None else now
    with _LOCK:
        expired = [code for code, jc in _CODES.items() if jc.exp_ts <= current]
        for code in expired:
            _CODES.pop(code, None)


def reset() -> None:
    """Reset stores (intended for tests)."""

    with _LOCK:
        _DEVICES.clear()
        _CODES.clear()


def mint_join_code(member_id: str, ttl_sec: int = 180) -> JoinCode:
    if ttl_sec <= 0:
        raise ValueError("ttl_sec must be positive")

    exp_ts = _now_s() + ttl_sec
    _purge_expired_codes()
    for _ in range(64):
        code = "".join(str(secrets.randbelow(10)) for _ in range(6))
        with _LOCK:
            if code in _CODES:
                continue
            join_code = JoinCode(code=code, member_id=member_id, exp_ts=exp_ts)
            _CODES[code] = join_code
            return replace(join_code)
    raise RuntimeError("unable to allocate join code")


def register_device() -> Device:
    dev = Device(device_id=_new_id(9), device_secret=_new_id(18), last_seen_ts=_now_s())
    with _LOCK:
        _DEVICES[dev.device_id] = dev
        return replace(dev)


def get_device(device_id: str) -> Optional[Device]:
    with _LOCK:
        device = _DEVICES.get(device_id)
        return replace(device) if device else None


def get_primary_device_for_member(member_id: str) -> Optional[Device]:
    """Return the most recently seen device bound to *member_id*, if any."""

    with _LOCK:
        candidates = [
            device
            for device in _DEVICES.values()
            if device.bound_member_id == member_id
        ]
        if not candidates:
            return None
        latest = max(candidates, key=lambda dev: dev.last_seen_ts)
        return replace(latest)


def bind_device_with_code(device_id: str, code: str) -> Device:
    _purge_expired_codes()
    with _LOCK:
        device = _DEVICES.get(device_id)
        join_code = _CODES.get(code)
        if device is None or join_code is None:
            raise KeyError("device or code not found")
        if _now_s() > join_code.exp_ts:
            _CODES.pop(code, None)
            raise ValueError("join code expired")
        device.bound_member_id = join_code.member_id
        _CODES.pop(code, None)
        return replace(device)


def unbind_device(device_id: str) -> None:
    with _LOCK:
        device = _DEVICES.get(device_id)
        if device is not None:
            device.bound_member_id = None
            device.last_ack_tip_id = None


def rotate_device_secret(device_id: str) -> Device:
    with _LOCK:
        device = _DEVICES.get(device_id)
        if device is None:
            raise KeyError("device not found")
        device.device_secret = _new_id(18)
        device.last_seen_ts = _now_s()
        return replace(device)


def make_device_token(device_id: str, device_secret: str, ttl_sec: int = 300) -> str:
    if ttl_sec <= 0:
        raise ValueError("ttl_sec must be positive")
    exp = _now_s() + ttl_sec
    with _LOCK:
        device = _DEVICES.get(device_id)
        if device is None or device.device_secret != device_secret:
            raise KeyError("invalid device credentials")
    payload = f"{device_id}.{exp}".encode()
    signature = hmac.new(device_secret.encode(), payload, hashlib.sha256).digest()
    sig_encoded = base64.urlsafe_b64encode(signature).decode().rstrip("=")
    return f"{device_id}.{exp}.{sig_encoded}"


def verify_device_token(token: str) -> Optional[Device]:
    try:
        parts = token.split(".")
        if len(parts) != 3:
            return None
        device_id, exp_raw, signature = parts
        exp = int(exp_raw)
    except (ValueError, TypeError):
        return None

    with _LOCK:
        device = _DEVICES.get(device_id)
        if device is None:
            return None
        expected_payload = f"{device_id}.{exp}".encode()
        expected_sig = hmac.new(
            device.device_secret.encode(), expected_payload, hashlib.sha256
        ).digest()
        expected_b64 = base64.urlsafe_b64encode(expected_sig).decode().rstrip("=")
        if not hmac.compare_digest(expected_b64, signature):
            return None
        if _now_s() > exp:
            return None
        device.last_seen_ts = _now_s()
        return replace(device)


def record_ack(device_id: str, tip_id: str) -> Optional[Device]:
    with _LOCK:
        device = _DEVICES.get(device_id)
        if device is None:
            return None
        device.last_ack_tip_id = tip_id
        device.last_seen_ts = _now_s()
        return replace(device)
