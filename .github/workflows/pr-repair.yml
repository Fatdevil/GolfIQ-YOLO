name: PR Repair
on:
  workflow_dispatch:
    inputs:
      pr:
        description: "PR-nummer att reparera (tomt = alla)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

jobs:
  repair:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    steps:
      - uses: actions/checkout@v5
        with: { fetch-depth: 0 }
      - uses: actions/setup-python@v6
        with:
          python-version: "3.11"
          cache: "pip"
      - name: Install deps
        run: |
          python -m pip install -U pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          if [ -f requirements-dev.txt ]; then pip install -r requirements-dev.txt; fi
      - name: Configure git user
        run: |
          git config user.name  "codex-pr-repair"
          git config user.email "codex-pr-repair@users.noreply.github.com"
      - name: Run repair script
        env:
          CODEX_PAT: ${{ secrets.CODEX_PAT }}
          GITHUB_PAT: ${{ secrets.GITHUB_PAT }}
          REPO: ${{ github.repository }}
          PR_INPUT: ${{ inputs.pr }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import json, os, subprocess, urllib.request
          repo=os.environ["REPO"]
          token=os.environ.get("CODEX_PAT") or os.environ.get("GITHUB_PAT")
          pr_in=os.environ.get("PR_INPUT"," ").strip()
          def api(path): 
              req=urllib.request.Request(f"https://api.github.com/repos/{repo}{path}",
                      headers={"Authorization":f"token {token}","Accept":"application/vnd.github+json"})
              return json.load(urllib.request.urlopen(req))
          def run(*c,check=True): subprocess.run(c,check=check)
          prs=[api(f"/pulls/{pr_in}")] if pr_in else api("/pulls?state=open&per_page=100")
          for p in prs:
              num=p["number"]; ref=p["head"]["ref"]; fork=p["head"]["repo"]["fork"]
              print(f"\n=== PR #{num} ({ref}) ===")
              if fork: print("fork -> skip"); continue
              run("git","fetch","origin",ref); run("git","checkout","-B",ref,f"origin/{ref}")
              # merge main
              run("git","merge","--no-edit","origin/main",check=False)
              c=subprocess.run(["git","ls-files","-u"],capture_output=True,text=True).stdout.strip()
              if c:
                  print("conflict -> skip"); run("git","merge","--abort",check=False); continue
              # tools
              try:
                  run("black","--version",check=False)
              except: run("python","-m","pip","install","black","isort","flake8","pytest",check=True)
              # format + tests (advisory lint)
              subprocess.run(["black","."],check=False)
              subprocess.run(["isort",".","--profile","black"],check=False)
              subprocess.run(["flake8","."],check=False)
              subprocess.run(["pytest","-q"],check=False)
              # commit if changes
              run("git","add","-A")
              if subprocess.run(["git","diff","--cached","--quiet"]).returncode!=0:
                  run("git","commit","-m",f"ci: auto-repair (#{num}) â€“ merge main + format")
                  run("git","push","origin",ref)
              else:
                  print("no changes")
          PY
